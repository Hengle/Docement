# 红黑树  
 基本思想是用标准的二叉查找树和一些额外的信息（红连接和黑连接）来表示2-3树。红连接将两个2-节点连接表示为一个3-节点。黑连接则为普通连接。  

 + 红连接均为左连接
 + 没有任何一个节点同时和两条红连接相连  
 + 完美黑色平衡。即任意空连接到根节点的路径上的黑连接数量相同  

 **红黑树既是二叉查找树，也是2-3树。有二叉树中简洁高效的查找方法，还有2-3树中平衡的插入算法**  

 ***旋转***

 在插入新键时我们可以使用旋转操作帮助我们保证其的两个重要特性：**有序性和完美平衡性**。  

 + 左旋转：修复红色右连接
 + 右旋转：修复连续红色左连接  

 ***插入***  

 必须遵循以下顺序操作
 1. 右节点红，左节点黑，左旋转
 2. 连续左节点红，右旋转  
 3. 左右都为红，颜色转换，即左右节点变黑，父节点由黑变红  

 ***删除***

 删除操作更加复杂，我们不仅要在构造林临时4-节点时沿着查找方向向下进行变换，还要在分解遗留的4-节点时沿着查找路径向上进行变换。  

 + 自顶向下的2-3-4树
    这个变换是为了在删除操作中，删除最小键时不会有2-节点被删除。因为删除2-节点会破坏树的平衡，删除3-，和临时构建的4-，则不会。

    2-3-4插入算法
    * 如果根节点是4-节点，我们就将它分解成3个2-节点，使得树高加1.
    * 在向下查找的过程中，如果遇到一个父节点为2-节点的4-节点，我们将4-节点分解成两个2-节点，并将中间节点传递给它的父节点，使得父节点变为3-节点。
    * 如果遇到一个父节点为3-节点的4-节点，我们将4-节点分解为两个2-节点，并将中间节点传递给他的父节点，使得父节点变为4-节点。  
    
我们不必担心父节点为4-节点的4-节点，插入算法本身就保证了这种情况不会出现。到达树的低部之后，我们就只会遇到2-节点和3-节点，这样我们就可以插入新的键了。  

+ 红黑树实现这个算法  
    + 将4-节点表示为由三个2-节点组成的一棵平衡的子树，根节点和两个子节点都用红连接相连
    + 在向下的过程中分解所有4-节点并进行颜色转换  
    + 和插入操作一样，在向上的过程中用旋转将4-节点配平  


+ 删除最小键（基于2-3树）  
为了保证我们不会删除一个2-节点，我们沿着左连接向下进行变换，确保当前节点不是2-节点。  
如果根节点是2-节点，且它的两个子节点都是2-节点，我们可以直接将这三个节点变成一个4-节点，否则我们需要保证根节点的左子节点不是2-节点，如果有必要可以从右边兄弟节点借来一个键。  
    + 如果当前节点的左子节点不是2-节点，完成  
    + 如果当前节点的左子节点是2-节点而它的兄弟节点不是2-节点，将左子节点的兄弟节点中的一个键移到左子节点中
    + 如果当前左子节点和它的兄弟节点都是2-节点，将它的左子节点、父节点的最小键和左子节点的兄弟节点组合成一个4-节点

在这个过程中，最后都能得到一个含有最小键的3-节点或者4-节点。然后我们就可以将最小键删除，将3-节点变为一个2-节点或者将4-节点变为一个3-节点。

删除操作，在查找删除键的过程中，进行和删除最小键相同的变换操作，这样就可以保证，查找过程中任意当前节点均不是2-节点。
+ 如果被查找的键在底部，就直接删除  
+ 如果不在底部，我们就需要让它和它的后续节点交换，即查找其右子树的最小子节点，然后与其交换。那么现在问题就变为了删除其子树的最小键操作，删除最小键的操作如上节所示。  

***性能分析***  
一棵大小为N的红黑树的高度不会超过2logN  
红黑树的最坏情况是它所对应的2-3树中构成最左边的路径节点，全部都是3-节点，而其余全部均为2-节点。  
最左边的路径长度是只包含2-节点的路径长度logN的两倍，所以最坏情况就是2logN，但这种情况出现的可能性极小  
这样结合最坏和最好的情况，那么一个大小为N的红黑树中，根节点到任意节点的平均路径长度为1.001logN

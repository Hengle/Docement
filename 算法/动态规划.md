# 动态规划  

[动态规划1](https://blog.csdn.net/baidu_37107022/article/details/73188963)
[动态规划2](https://blog.csdn.net/baidu_37107022/article/details/73189125)
[动态规划3](https://blog.csdn.net/baidu_37107022/article/details/78253222)  

**原理**：动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。**当前最优子解，只受上个最优子解的影响。**

**表格推导可求出最优解**

# KMP  

# 分治

# 贪心  

# A* 寻路  

# 广度优先 深度优先  

# TopN算法
如：1亿个随机数数 找到最大前10个数  

+ ***算法1：普通排序***
    **快速排序**：算法时间复杂度为 $NlogN$ 
    **进一步优化**：随机取准、三数取中、合理利用插入排序、双向循环  

> 

+  ***算法2：部分排序***
    维护一个需要排序的数组$K$，遍历所有数据，和数组$K$内进行比较，并根据大小顺序插入，插入数据的复杂度为$N$。所有数据遍历完成后，数组$K$就是要查找的结果。算法复杂度为 $K*N$  

> 

+ ***算法3：引入堆***
    在算法二中，我们已经将时间复杂度由$NlogN$优化到$NK$，现在我们想办法把K优化一下。
    基于以上的分析，我们想想，有没有一种既能快速查找，又能快速移动元素的数据结构呢？回答是肯定的，那就是**堆**。根据需求选择大顶堆和小顶堆，堆在插入数据的时间复杂度为$logK$，所以现在的总共时间复杂度为$logK*N$


[Hash表算法及TopN问题](https://blog.csdn.net/oitebody/article/details/60487045)
# 动态规划  

[动态规划1](https://blog.csdn.net/baidu_37107022/article/details/73188963)
[动态规划2](https://blog.csdn.net/baidu_37107022/article/details/73189125)
[动态规划3](https://blog.csdn.net/baidu_37107022/article/details/78253222)  

**原理**：动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。**当前最优子解，只受上个最优子解的影响。**

**表格推导可求出最优解**

******
# 贪心  

贪心算法是指，在对问题求解时，总是做出在当前看来最好的选择。也就是说，不从整体最优解出发来考虑，它所做出的**仅是在某种意义上的局部最优解**。 
贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题都能产生**整体最优解或整体最优解的近似解**。
>

贪心算法的基本思路如下： 
1. 建立数学模型来描述问题。 
2. 把求解的问题分成若干个子问题。 
3. 对每个子问题求解，得到每个子问题的局部最优解。 
4. 把每个子问题的局部最优解合成为原来问题的一个解。 

[贪心算法经典例子](https://blog.csdn.net/wang704987562/article/details/70991590)


***贪心和动态规划的区别***
1. 贪心算法作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。
2. 动态规划算法的全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有局部最优解；
******


# KMP  

******

# 分治  

归并排序 就是分治思想

******

# TopN算法
如：1亿个随机数数 找到最大前10个数  

+ ***算法1：普通排序***
    **快速排序**：算法时间复杂度为 $NlogN$ 
    **进一步优化**：随机取准、三数取中、合理利用插入排序、双向循环  

> 

+  ***算法2：部分排序***
    维护一个需要排序的数组$K$，遍历所有数据，和数组$K$内进行比较，并根据大小顺序插入，插入数据的复杂度为$N$。所有数据遍历完成后，数组$K$就是要查找的结果。算法复杂度为 $K*N$  

> 

+ ***算法3：引入堆***
    在算法二中，我们已经将时间复杂度由$NlogN$优化到$NK$，现在我们想办法把K优化一下。
    基于以上的分析，我们想想，有没有一种既能快速查找，又能快速移动元素的数据结构呢？回答是肯定的，那就是**堆**。根据需求选择大顶堆和小顶堆，堆在插入数据的时间复杂度为$logK$，所以现在的总共时间复杂度为$logK*N$


[Hash表算法及TopN问题](https://blog.csdn.net/oitebody/article/details/60487045)

******

# A*算法  
[什么是A\*寻路算法](http://www.sohu.com/a/191037466_478315)
[理解A\*寻路算法具体过程](https://www.cnblogs.com/technology/p/2058842.html) 

******

# 第一排42481255156，第二排显示数字出现的次数  
[题目](http://lg-asus.iteye.com/blog/1910112)
[题目2](https://blog.csdn.net/u012333003/article/details/24627495)  

0 1 2 3 4 5 6 7 8 9  

+ 分析：
首先5 6 7 8 9 下面不可能出现2及其以上的数字，如果出现，说明其他2个以上的数字下面会出现5 6 7 8 9，空位根本不够。
如果9下面是1，则出现一个9，这个9放在任何位置该数字都要出现9次，但剩余空间只有8个，所以9下面只能是0。
如果8下面是1，则出现一个8，这个8放在0位置，则剩下空位全部是0，但是1又出现了一次，不成立。这个8放在1下面，其他空位全部是1，但其他数字又都没出现，也不成立，以此类推。所以8下面只能是0。
如果7下面是1，则出现一个7，这个7放在0下面，则有7个空位被0占用，只有一个空位下面可以填写其他数字，但是填写任意数字都是不合法的，填写大于等于1的数字，但是又没出现过，填写0，就和0下的数字不匹配了，所以7下面也只能填写0。

$n0+n1+n2+n3+n4+n5+n6+n7+n8+n9=10$  
$0n0+1n1+2n2+3n3+4n4+5n5+6n6+7n7+8n8+9n9=10$

依次类推答案为 
0 1 2 3 4 5 6 7 8 9 对应
6 2 1 0 0 0 1 0 0 0 

0 1 2 3 4 5 6 7 对应
4 2 1 0 1 0 0 0 

0 1 2 3 4 5 无解


# 二叉树遍历 递归和非递归 

**递归**  
1. 出递归条件是当前节点为空  
2. 递归左节点  
3. 递归右节点  

**非递归**  
递归也可以用栈的方式来保存数据，所以可以用非递归的方式实现。  
1. 申请一个新的栈Stack，然后将头节点压入Stack
2. 弹出栈顶H，H的右子节点不为空入栈，H的左子节点不为空入栈
3. 重复2，直到栈Stack为空

****** 

# 二叉树 广度优先 深度优先  

深度优先就是二叉树的中序 左 根 右  
广度优先就是二叉树的先序 根 左 右

[二叉树深度优先和广度优先遍历](https://www.cnblogs.com/attitudeY/p/6790219.html)

******  

# 多进程  python

进程间的数据冲突
进程返回参数 判断执行是否成功 

******

# 反射向量推到  

******

# 快速傅里叶变换 FFT

******
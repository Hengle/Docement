# 动态规划  

[动态规划1](https://blog.csdn.net/baidu_37107022/article/details/73188963)
[动态规划2](https://blog.csdn.net/baidu_37107022/article/details/73189125)
[动态规划3](https://blog.csdn.net/baidu_37107022/article/details/78253222)  

**原理**：动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到。**当前最优子解，只受上个最优子解的影响。**

**表格推导可求出最优解**

******
# 贪心  

贪心算法是指，在对问题求解时，总是做出在当前看来最好的选择。也就是说，不从整体最优解出发来考虑，它所做出的**仅是在某种意义上的局部最优解**。 
贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题都能产生**整体最优解或整体最优解的近似解**。
>

贪心算法的基本思路如下： 
1. 建立数学模型来描述问题。 
2. 把求解的问题分成若干个子问题。 
3. 对每个子问题求解，得到每个子问题的局部最优解。 
4. 把每个子问题的局部最优解合成为原来问题的一个解。 

[贪心算法经典例子](https://blog.csdn.net/wang704987562/article/details/70991590)


***贪心和动态规划的区别***
1. 贪心算法作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留。
2. 动态规划算法的全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有局部最优解；
******


# KMP  

[KMP算法详解](https://blog.csdn.net/yutianzuijin/article/details/11954939)

******

# 回溯算法  

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

[回溯算法](https://www.cnblogs.com/jiangchen/p/5393849.html)

******

# 分治  

归并排序 就是分治思想

******

# TopN算法
如：1亿个随机数数 找到最大前10个数  

+ ***算法1：普通排序***
    **快速排序**：算法时间复杂度为 $NlogN$ 
    **进一步优化**：随机取准、三数取中、合理利用插入排序、双向循环  

> 

+  ***算法2：部分排序***
    维护一个需要排序的数组$K$，遍历所有数据，和数组$K$内进行比较，并根据大小顺序插入，插入数据的复杂度为$N$。所有数据遍历完成后，数组$K$就是要查找的结果。算法复杂度为 $K*N$  

> 

+ ***算法3：引入堆***
    在算法二中，我们已经将时间复杂度由$NlogN$优化到$NK$，现在我们想办法把K优化一下。
    基于以上的分析，我们想想，有没有一种既能快速查找，又能快速移动元素的数据结构呢？回答是肯定的，那就是**堆**。根据需求选择大顶堆和小顶堆，堆在插入数据的时间复杂度为$logK$，所以现在的总共时间复杂度为$logK*N$


[Hash表算法及TopN问题](https://blog.csdn.net/oitebody/article/details/60487045)

******

# A*算法  
[什么是A\*寻路算法](http://www.sohu.com/a/191037466_478315)
[理解A\*寻路算法具体过程](https://www.cnblogs.com/technology/p/2058842.html) 

******

# 第一排42481255156，第二排显示数字出现的次数  
[题目](http://lg-asus.iteye.com/blog/1910112)
[题目2](https://blog.csdn.net/u012333003/article/details/24627495)  

0 1 2 3 4 5 6 7 8 9  

+ 分析：
首先5 6 7 8 9 下面不可能出现2及其以上的数字，如果出现，说明其他2个以上的数字下面会出现5 6 7 8 9，空位根本不够。
如果9下面是1，则出现一个9，这个9放在任何位置该数字都要出现9次，但剩余空间只有8个，所以9下面只能是0。
如果8下面是1，则出现一个8，这个8放在0位置，则剩下空位全部是0，但是1又出现了一次，不成立。这个8放在1下面，其他空位全部是1，但其他数字又都没出现，也不成立，以此类推。所以8下面只能是0。
如果7下面是1，则出现一个7，这个7放在0下面，则有7个空位被0占用，只有一个空位下面可以填写其他数字，但是填写任意数字都是不合法的，填写大于等于1的数字，但是又没出现过，填写0，就和0下的数字不匹配了，所以7下面也只能填写0。

$n0+n1+n2+n3+n4+n5+n6+n7+n8+n9=10$  
$0n0+1n1+2n2+3n3+4n4+5n5+6n6+7n7+8n8+9n9=10$

依次类推答案为 
0 1 2 3 4 5 6 7 8 9 对应
6 2 1 0 0 0 1 0 0 0 

0 1 2 3 4 5 6 7 对应
4 2 1 0 1 0 0 0 

0 1 2 3 4 5 无解

# 多进程  python

进程间的数据冲突
进程返回参数 判断执行是否成功 

******

# 反射向量推到  

******

# 快速傅里叶变换 FFT

******  

# 一致性哈希  

![consisthash](textures/consisthash.png)

将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。

**一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。**

一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成**数据倾斜**问题，用**虚拟节点**解决 

[一致性哈希算法原理](https://www.cnblogs.com/lpfuture/p/5796398.html)

******

# 黑白球问题

《编程之美》的概率题：一个桶里面有白球、黑球各100个，现在按下述规则取球：
    i 、每次从袋子里面拿出来两个球；
    ii、如果取出的是两个同色的球，就再放入一个黑球；
    ii、如果取出的是两个异色的球，就再放入一个白球。
问：最后袋子里面只剩下一个黑球的概率是多少？

第一种方案（只关注一种球的变化）：

```
    i.如果取出的是两个白球，白球减少2个。
    ii.如果取出的是两个黑球，白球不变。
    iii.如果取出的是一黑一白，再放入一个白球，导致白球没变。
    综上，白球的变化情况是2，0，0，所以白球只会存在偶数，不会单独的
    存在一个白球，所以最后不可能剩下白球。那么剩下黑球的可能性就是0
    或者100%100，因为这三种情况都是拿两个放一个，实际上只拿了一个，
    那么最后一定会剩下一个球，这是按一个递减的，所以排除0的可能，那么
    最后桶里面剩余黑球的可能性就是100%100。
```
> 

扩展：如果袋子里面有黑色球与白色球各101呢？
```
    先将100个黑球与100个白球按第一种方案得出剩余一个黑球，那么
    现在还剩余2个黑球与1个白球，要么1黑1白取两次，最后剩余白，
    要么2黑，黑白，剩余的依然是白球，所以剩余的是白球。
```



第二种方案(推荐方案)：
亦或方法
```
    黑球假设为0，白球假设为1。
    i.黑(0) ^ 白球(1) = 白球(1)
    ii.黑(0) ^ 黑(0)  = (黑)0
    ii.白(1) ^ 白(1)  = (黑)0  

    ^0^0^0^...1^1^1^1^1 = ?

    根据以上公式，可以得到

    如果数量是偶数的话，最后都能化简为
    0 ^ 0 = 0 所以最后剩余黑球 

    如果数量是奇数的话，租后都能化简为
    0 ^ 1 = 1 所以最后剩余白球
```

结论：**偶数对黑球白球最后剩余的是黑球，奇数对黑球白球最后剩余的是白球。**

[100对黑白球问题的多种思路](https://blog.csdn.net/u010187139/article/details/79694888) 

******  

# 翻转链表  


```
node* reverseList(node* H)
{
    if (H == NULL || H->next == NULL) //链表为空或者仅1个数直接返回
        return H;
    node* p = H, *newH = NULL;
    while (p != NULL)                 //一直迭代到链尾
    {
        node* tmp = p->next;          //暂存p下一个地址，防止变化指针指向后找不到后续的数
        p->next = newH;               //p->next指向前一个空间
        newH = p;                     //新链表的头移动到p，扩长一步链表
        p    = tmp;                   //p指向原始链表p指向的下一个空间
    }
    return newH;
}

```

[链表翻转的图文讲解（递归与迭代两种实现）](https://blog.csdn.net/fx677588/article/details/72357389?utm_source=copy)

******  

# 删除链表的倒数K节点 

**思路:**
1、定义两个游标p、q
2、p向前移动k个步长
3、如果此时p为空，则返回head.next
4、p和q同时向后移动一定步长，直到p.next=null，即p为最后节点
5、删除倒数k节点，q.next=q.next.next
6、返回head

```

    ListNode removeNthFromEnd(ListNode head, int n) {
        // write your code here
       
        ListNode p=head;
        ListNode q=head;
        for(int i=0;i<n;i++){
            p=p.next;
        }
        if(p==null){
            head=head.next;
            return head;
        }
        while(p.next!=null){
            p=p.next;
            q=q.next;
        }
        q.next=q.next.next;
        return head;
    
    }

```

******  

# 画曲线 贝塞尔曲线

[贝塞尔曲线](https://blog.csdn.net/xiexian1204/article/details/49592765)  
[贝塞尔曲线初探](http://www.cnblogs.com/jay-dong/archive/2012/09/26/2704188.html)

******
